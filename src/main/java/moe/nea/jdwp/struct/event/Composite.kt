package moe.nea.jdwp.struct.event

import moe.nea.jdwp.*
import moe.nea.jdwp.primitives.*
import moe.nea.jdwp.base.*

/**
 * Several events may occur at a given time in the target VM. For example, there may be more than one breakpoint request for a given location or you might single step to the same location as a breakpoint request.  These events are delivered together as a composite event.  For uniformity, a composite event is always used to deliver events, even if there is only one event to report. 
 * The invoke options are a combination of zero or more of the following bit flags:
 * [External](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_Event_Composite)
 */
class Composite : JDWPComposite(), JDWPCommandPayload<CompositeReply> {
    /**
     * Which threads where suspended by this composite event?
     */
    var suspendPolicy by useField(JDWPByte())
    /**
     * Events in set.
     */
    var events by useField(JDWPInt())
    var eventsElements by useField(JDWPExternalVector(this::events, ::CompositeEventsElement))
    override val reply = CompositeReply()
    override val commandId: UByte get() = 100.toUByte()
    override val commandSetId: UByte get() = 64.toUByte()
}
/**
 * Reply for [Composite]
 */
class CompositeReply : JDWPComposite(), JDWPReplyPayload {
}



/**
 * Component for [Composite]
 */
class CompositeEventsElement : JDWPComposite() {
    /**
     * Event kind selector
     */
    var eventKind by useField(JDWPByte())
    /**
     * Notification of initialization of a target VM.  This event is received before the main thread is started and before any application code has been executed. Before this event occurs a significant amount of system code has executed and a number of system classes have been loaded. This event is always generated by the target VM, even if not explicitly requested.
     */
    var VMStart by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.VM_START, CompositeVMStart()))
    /**
     * Notification of step completion in the target VM. The step event is generated before the code at its location is executed.
     */
    var SingleStep by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.SINGLE_STEP, CompositeSingleStep()))
    /**
     * Notification of a breakpoint in the target VM. The breakpoint event is generated before the code at its location is executed.
     */
    var Breakpoint by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.BREAKPOINT, CompositeBreakpoint()))
    /**
     * Notification of a method invocation in the target VM. This event is generated before any code in the invoked method has executed. Method entry events are generated for both native and non-native methods. In some VMs method entry events can occur for a particular thread before its thread start event occurs if methods are called as part of the thread's initialization.
     */
    var MethodEntry by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.METHOD_ENTRY, CompositeMethodEntry()))
    /**
     * Notification of a method return in the target VM. This event is generated after all code in the method has executed, but the location of this event is the last executed location in the method. Method exit events are generated for both native and non-native methods. Method exit events are not generated if the method terminates with a thrown exception.
     */
    var MethodExit by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.METHOD_EXIT, CompositeMethodExit()))
    /**
     * Notification of a method return in the target VM. This event is generated after all code in the method has executed, but the location of this event is the last executed location in the method. Method exit events are generated for both native and non-native methods. Method exit events are not generated if the method terminates with a thrown exception. Since JDWP version 1.6.
     */
    var MethodExitWithReturnValue by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.METHOD_EXIT_WITH_RETURN_VALUE, CompositeMethodExitWithReturnValue()))
    /**
     * Notification that a thread in the target VM is attempting to enter a monitor that is already acquired by another thread. Requires canRequestMonitorEvents capability - see [CapabilitiesNew](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_VirtualMachine_CapabilitiesNew). Since JDWP version 1.6.
     */
    var MonitorContendedEnter by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.MONITOR_CONTENDED_ENTER, CompositeMonitorContendedEnter()))
    /**
     * Notification of a thread in the target VM is entering a monitor after waiting for it to be released by another thread. Requires canRequestMonitorEvents capability - see [CapabilitiesNew](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_VirtualMachine_CapabilitiesNew). Since JDWP version 1.6.
     */
    var MonitorContendedEntered by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.MONITOR_CONTENDED_ENTERED, CompositeMonitorContendedEntered()))
    /**
     * Notification of a thread about to wait on a monitor object. Requires canRequestMonitorEvents capability - see [CapabilitiesNew](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_VirtualMachine_CapabilitiesNew). Since JDWP version 1.6.
     */
    var MonitorWait by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.MONITOR_WAIT, CompositeMonitorWait()))
    /**
     * Notification that a thread in the target VM has finished waiting on Requires canRequestMonitorEvents capability - see [CapabilitiesNew](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_VirtualMachine_CapabilitiesNew). a monitor object. Since JDWP version 1.6.
     */
    var MonitorWaited by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.MONITOR_WAITED, CompositeMonitorWaited()))
    /**
     * Notification of an exception in the target VM. If the exception is thrown from a non-native method, the exception event is generated at the location where the exception is thrown. If the exception is thrown from a native method, the exception event is generated at the first non-native location reached after the exception is thrown.
     */
    var Exception by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.EXCEPTION, CompositeException()))
    /**
     * Notification of a new running thread in the target VM. The new thread can be the result of a call to java.lang.Thread.start or the result of attaching a new thread to the VM though JNI. The notification is generated by the new thread some time before its execution starts. Because of this timing, it is possible to receive other events for the thread before this event is received. (Notably, Method Entry Events and Method Exit Events might occur during thread initialization. It is also possible for the [VirtualMachine AllThreads](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_VirtualMachine_AllThreads) command to return a thread before its thread start event is received. Note that this event gives no information about the creation of the thread object which may have happened much earlier, depending on the VM being debugged.
     */
    var ThreadStart by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.THREAD_START, CompositeThreadStart()))
    /**
     * Notification of a completed thread in the target VM. The notification is generated by the dying thread before it terminates. Because of this timing, it is possible for {@link VirtualMachine#allThreads} to return this thread after this event is received. Note that this event gives no information about the lifetime of the thread object. It may or may not be collected soon depending on what references exist in the target VM.
     */
    var ThreadDeath by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.THREAD_DEATH, CompositeThreadDeath()))
    /**
     * Notification of a class prepare in the target VM. See the JVM specification for a definition of class preparation. Class prepare events are not generated for primtiive classes (for example, java.lang.Integer.TYPE).
     */
    var ClassPrepare by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.CLASS_PREPARE, CompositeClassPrepare()))
    /**
     * Notification of a class unload in the target VM. There are severe constraints on the debugger back-end during garbage collection, so unload information is greatly limited.
     */
    var ClassUnload by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.CLASS_UNLOAD, CompositeClassUnload()))
    /**
     * Notification of a field access in the target VM. Field modifications are not considered field accesses. Requires canWatchFieldAccess capability - see [CapabilitiesNew](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_VirtualMachine_CapabilitiesNew).
     */
    var FieldAccess by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.FIELD_ACCESS, CompositeFieldAccess()))
    /**
     * Notification of a field modification in the target VM. Requires canWatchFieldModification capability - see [CapabilitiesNew](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_VirtualMachine_CapabilitiesNew).
     */
    var FieldModification by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.FIELD_MODIFICATION, CompositeFieldModification()))
    var VMDeath by useField(JDWPCase(this::eventKind, JDWPEventKindConstants.VM_DEATH, CompositeVMDeath()))
}


/**
 * Component for [Composite]
 */
class CompositeVMStart : JDWPComposite() {
    /**
     * Request that generated event (or 0 if this event is automatically generated.
     */
    var requestID by useField(JDWPInt())
    /**
     * Initial thread
     */
    var thread by useField(JDWPThreadId())
}



/**
 * Component for [Composite]
 */
class CompositeSingleStep : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Stepped thread
     */
    var thread by useField(JDWPThreadId())
    /**
     * Location stepped to
     */
    val location by useField(JDWPLocation())
}




/**
 * Component for [Composite]
 */
class CompositeBreakpoint : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Thread which hit breakpoint
     */
    var thread by useField(JDWPThreadId())
    /**
     * Location hit
     */
    val location by useField(JDWPLocation())
}




/**
 * Component for [Composite]
 */
class CompositeMethodEntry : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Thread which entered method
     */
    var thread by useField(JDWPThreadId())
    /**
     * The initial executable location in the method.
     */
    val location by useField(JDWPLocation())
}




/**
 * Component for [Composite]
 */
class CompositeMethodExit : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Thread which exited method
     */
    var thread by useField(JDWPThreadId())
    /**
     * Location of exit
     */
    val location by useField(JDWPLocation())
}




/**
 * Component for [Composite]
 */
class CompositeMethodExitWithReturnValue : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Thread which exited method
     */
    var thread by useField(JDWPThreadId())
    /**
     * Location of exit
     */
    val location by useField(JDWPLocation())
    /**
     * Value that will be returned by the method
     */
    val value by useField(JDWPValue())
}





/**
 * Component for [Composite]
 */
class CompositeMonitorContendedEnter : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Thread which is trying to enter the monitor
     */
    var thread by useField(JDWPThreadId())
    /**
     * Monitor object reference
     */
    val `object` by useField(JDWPTaggedObjectId())
    /**
     * Location of contended monitor enter
     */
    val location by useField(JDWPLocation())
}





/**
 * Component for [Composite]
 */
class CompositeMonitorContendedEntered : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Thread which entered monitor
     */
    var thread by useField(JDWPThreadId())
    /**
     * Monitor object reference
     */
    val `object` by useField(JDWPTaggedObjectId())
    /**
     * Location of contended monitor enter
     */
    val location by useField(JDWPLocation())
}





/**
 * Component for [Composite]
 */
class CompositeMonitorWait : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Thread which is about to wait
     */
    var thread by useField(JDWPThreadId())
    /**
     * Monitor object reference
     */
    val `object` by useField(JDWPTaggedObjectId())
    /**
     * Location at which the wait will occur
     */
    val location by useField(JDWPLocation())
    /**
     * Thread wait time in milliseconds
     */
    var timeout by useField(JDWPLong())
}






/**
 * Component for [Composite]
 */
class CompositeMonitorWaited : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Thread which waited
     */
    var thread by useField(JDWPThreadId())
    /**
     * Monitor object reference
     */
    val `object` by useField(JDWPTaggedObjectId())
    /**
     * Location at which the wait occured
     */
    val location by useField(JDWPLocation())
    /**
     * True if timed out
     */
    var timed_out by useField(JDWPBoolean())
}






/**
 * Component for [Composite]
 */
class CompositeException : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Thread with exception
     */
    var thread by useField(JDWPThreadId())
    /**
     * Location of exception throw (or first non-native location after throw if thrown from a native method)
     */
    val location by useField(JDWPLocation())
    /**
     * Thrown exception
     */
    val exception by useField(JDWPTaggedObjectId())
    /**
     * Location of catch, or 0 if not caught. An exception is considered to be caught if, at the point of the throw, the current location is dynamically enclosed in a try statement that handles the exception. (See the JVM specification for details). If there is such a try statement, the catch location is the first location in the appropriate catch clause. If there are native methods in the call stack at the time of the exception, there are important restrictions to note about the returned catch location. In such cases, it is not possible to predict whether an exception will be handled by some native method on the call stack. Thus, it is possible that exceptions considered uncaught here will, in fact, be handled by a native method and not cause termination of the target VM. Furthermore, it cannot be assumed that the catch location returned here will ever be reached by the throwing thread. If there is a native frame between the current location and the catch location, the exception might be handled and cleared in that native method instead. Note that compilers can generate try-catch blocks in some cases where they are not explicit in the source code; for example, the code generated for synchronized and finally blocks can contain implicit try-catch blocks. If such an implicitly generated try-catch is present on the call stack at the time of the throw, the exception will be considered caught even though it appears to be uncaught from examination of the source code.
     */
    val catchLocation by useField(JDWPLocation())
}






/**
 * Component for [Composite]
 */
class CompositeThreadStart : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Started thread
     */
    var thread by useField(JDWPThreadId())
}



/**
 * Component for [Composite]
 */
class CompositeThreadDeath : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Ending thread
     */
    var thread by useField(JDWPThreadId())
}



/**
 * Component for [Composite]
 */
class CompositeClassPrepare : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Preparing thread. In rare cases, this event may occur in a debugger system thread within the target VM. Debugger threads take precautions to prevent these events, but they cannot be avoided under some conditions, especially for some subclasses of java.lang.Error. If the event was generated by a debugger system thread, the value returned by this method is null, and if the requested  [suspend policy](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_SuspendPolicy) for the event was EVENT_THREAD all threads will be suspended instead, and the composite event's suspend policy will reflect this change. Note that the discussion above does not apply to system threads created by the target VM during its normal (non-debug) operation.
     */
    var thread by useField(JDWPThreadId())
    /**
     * Kind of reference type. See [JDWP.TypeTag](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_TypeTag)
     */
    var refTypeTag by useField(JDWPByte())
    /**
     * Type being prepared
     */
    var typeID by useField(JDWPReferenceTypeId())
    /**
     * Type signature
     */
    var signature by useField(JDWPString())
    /**
     * Status of type. See [JDWP.ClassStatus](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_ClassStatus)
     */
    var status by useField(JDWPInt())
}







/**
 * Component for [Composite]
 */
class CompositeClassUnload : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Type signature
     */
    var signature by useField(JDWPString())
}



/**
 * Component for [Composite]
 */
class CompositeFieldAccess : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Accessing thread
     */
    var thread by useField(JDWPThreadId())
    /**
     * Location of access
     */
    val location by useField(JDWPLocation())
    /**
     * Kind of reference type. See [JDWP.TypeTag](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_TypeTag)
     */
    var refTypeTag by useField(JDWPByte())
    /**
     * Type of field
     */
    var typeID by useField(JDWPReferenceTypeId())
    /**
     * Field being accessed
     */
    var fieldID by useField(JDWPFieldId())
    /**
     * Object being accessed (null=0 for statics
     */
    val `object` by useField(JDWPTaggedObjectId())
}








/**
 * Component for [Composite]
 */
class CompositeFieldModification : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
    /**
     * Modifying thread
     */
    var thread by useField(JDWPThreadId())
    /**
     * Location of modify
     */
    val location by useField(JDWPLocation())
    /**
     * Kind of reference type. See [JDWP.TypeTag](https://docs.oracle.com/en/java/javase/21/docs/specs/jdwp/jdwp-protocol.html#JDWP_TypeTag)
     */
    var refTypeTag by useField(JDWPByte())
    /**
     * Type of field
     */
    var typeID by useField(JDWPReferenceTypeId())
    /**
     * Field being modified
     */
    var fieldID by useField(JDWPFieldId())
    /**
     * Object being modified (null=0 for statics
     */
    val `object` by useField(JDWPTaggedObjectId())
    /**
     * Value to be assigned
     */
    val valueToBe by useField(JDWPValue())
}









/**
 * Component for [Composite]
 */
class CompositeVMDeath : JDWPComposite() {
    /**
     * Request that generated event
     */
    var requestID by useField(JDWPInt())
}

